---
title: "Efeitos de sinais multimodais ao tempo até o início do amplexo: um estudo de simulação"
author: "Daniel YM Nakamura e Jennifer P Auler"
date: '2022-11-08'
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Introdução

Em anuros, o canto de anúncio é aquele emitido por machos para atrair fêmeas ou repelir machos competidores na paisagem acústica (Wells 1977). Na espécie *Hylodes asper* (Anura: Hylodidae), machos de anuros geralmente são sedentários e esperam até as fêmeas chegarem nos sítios reprodutivos (superfícies de rochas próximas a rios ou cachoeira). A maioria dos estudos utiliza aspectos temporais (e.g. taxa de cantos) ou espectrais (i.e. o quão agudo ou grave o canto é) como variáveis respostas de modelos. Contudo, o tempo em que as fêmeas demoram para chegar nos sítios reprodutivos e iniciarem o amplexo é pouco estudado.

Existem sinais multimodais compostos por características morfológicas, acústicas e visuais que são consideradas mais atrativas pelas fêmeas e podem explicar o tempo até sua chegada e início do amplexo. Por exemplo, é possível que machos que cantem a uma **taxa de notas** mais alta (maior número de notas por unidade de tempo) sejam mais atrativos e reduzam o tempo até o amplexo, pois uma taxa maior indica um maior gasto de energia e uma maior exposição a predadores, o que pode indicar um sinal honesto da qualidade do macho. Outra possível preditora acústica é a **frequência dominante** do canto, no qual cantos mais graves são considerados mais atrativos e talvez reduzam o tempo até o início do amplexo, pois machos com canto mais grave geralmente tem cordas vocais mais grossas e compridas, o que geralmente é um sinal honesto que informa o tamanho corporal do macho. Contudo, existem machos que mentem! Machos mentirosos são comuns em algumas espécies, os quais conseguem modular a frequência do canto (deixar mais grave por relaxamento dos músculos da cartilagem aritenóide). Por isso, incluir o **tamanho corporal** como uma variável preditora é uma forma de avaliar a honestidade da frequência. Por fim, machos da espécie *Hylodes asper* às vezes cantam ao mesmo tempo em que apresentam um display visual chamado *foot-flagging*, no qual esticam as pernas para chamarem atenção das fêmeas visualmente devido ao barulho das corredeiras que podem reduzir as chances de serem escutados pelas fêmeas. Portanto, uma última hipótese é que uma taxa de foot-flagging alta reduza o tempo até as fêmeas iniciarem o amplexo.

![](./fig1.png)

# 2. Material e métodos

## 2.1 Simulação de dados

```{r ass.function}
posicao = function(esc, espaco){
  if(!any(espaco == esc, na.rm = TRUE)){
    stop(paste0("nao existe o sapo <", esc, "> no espaco"))
  }
  area = dim(espaco)[1]
  posesc = which(espaco == esc)
  inicol = seq(1, area^2, by = area)
  fimcol = seq(area, area^2, by = area)
  whcol = posesc >= inicol & posesc <= fimcol
  col = which(whcol == TRUE)
  
  row = posesc - area*(col-1)
  res = c(row, col)
  names(res) = c("y.row", "x.col")
  return(res)
}

dist = function(posf, posesc){
  xf = posf[2]
  yf = posf[1]
  xm = posesc[2]
  ym = posesc[1]
 d = sqrt((xm - xf)^2 + (ym - yf)^2)
 return(unname(d))
}

padroniza = function(x){
  (x - mean(x))/sd(x)
}

logit2prob <- function(logit){
  odds <- exp(logit)
  prob <- odds / (1 + odds)
  return(prob)
}
```


```{r parametros}
nsim = 10
vecarea = round(runif(nsim, 10, 20), 0)
vecnmacho= vecarea

#coeficientes
cffreq = 1.05
cftama = 0.5
cffoot = 0.8
```


Espaço é uma matriz de \code{area} linhas e \code{area} colunas. 

```{r simulacao}
#set.seed(1)

saposim = function(nsim = 1000, vecarea = round(runif(nsim, 10, 100), 0), vecnmacho= vecarea, cffreq = 1.05, cftama = 0.5, cffoot = 0.8){
  
  #checagem de input
  if(length(vecarea) != nsim){stop("vecarea deve ser um vetor de tamanho nsim")}
  if(length(vecnmacho) != nsim){stop("vecnmacho deve ser um vetor de tamanho nsim")}
  
  #Cria objetos que vao ser usados no for
  result = data.frame(machoid = NA, dcach = NA, foot = NA, freq = NA, tama = NA, footpad = NA, freqpad = NA, tamapad = NA, exprlin = NA, prob = NA, distf = NA, ttot = NA, nsim = NA, femea = NA, area = NA)
  posf = data.frame(posx = NA, posy = NA, nfemea = NA) #atualmente nao esta como output
  storepos = list(NA) #atualmente nao esta como output
  
  ###############################################
  ############ INICIO FOR EXTERNO ###############
  ###############################################
  
  for(k in 1:nsim){
    
    #nmachos e area para esse espaco
    nmacho = vecnmacho[k]
    area = vecarea[k]
    
    #### Conformacao inicial do espaco ####
    # Simula espaço contendo areaXarea grids
    espaco = matrix(NA, ncol = area, nrow = area)
    dimnames(espaco) = list(paste("L", 1:area), paste("C", 1:area))
    
    # Simula spawn de 10 machos
    xmacho = sample(1:area, nmacho)
    ymacho = sample(1:area, nmacho)
    
    for(i in 1:nmacho){
      espaco[ymacho[i],xmacho[i]] = paste0("m", i)
    }
    espaco_orig = espaco
    
    #### Probabilidade de escolha dos machos ####
    dados = data.frame(machoid = paste0("m", 1:nmacho), dcach = NA, foot = NA, freq = NA, tama = NA, footpad = NA, freqpad = NA, tamapad = NA, exprlin = NA, prob = NA, distf = NA, ttot = NA, nsim = NA, femea = NA, area = NA)
    
    ##### simula caracteristicas dos machos #####
    dados$dcach = area-xmacho
    
    mfoot = 10 + dados$dcach*(-0.5)
    mfoot[mfoot<0] = 0
    
    sfreq = dados$dcach*(10*(1/area))
    mfreq = 2000 - mean(sfreq) +sfreq
    
    stama = dados$dcach*(0.5*(1/area))
    mtama = 40.4 - mean(stama) + stama
    
    dados$foot = rpois(nmacho, lambda = mfoot)
    dados$freq = rnorm(nmacho, mean = mfreq, sd = 200)
    dados$tama = rnorm(nmacho, mean = mtama, sd = 2)
    
    dados$footpad = padroniza(dados$foot)
    dados$tamapad = padroniza(dados$tama)  
    dados$freqpad = padroniza(dados$freq)
    
    ##### logistica #####
    
    dados$exprlin = cftama*dados$tamapad + cffoot*dados$footpad + cffreq*dados$freqpad
    dados$exprlin = dados$exprlin - mean(dados$exprlin)
    dados$prob = exp(dados$exprlin)/ (1+exp(dados$exprlin))
    dados$prob
    
    mdisp = dados$machoid
    mindisp = NA
    
    ####################################################
    ################ INICIO FOR INTERNO ################
    ####################################################
    
    for(j in 1:nmacho){
      
      # Simula spawn de 1 femea
      xfemea = sample(1:area, 1)
      yfemea = sample(1:area, 1)
      
      
      femeas = paste0("f", c(paste0(0, 1:9), 10:nmacho))
      posf[j,] = c(xfemea, yfemea, femeas[j])
      
      #checa se cedula esta ocupada
      while(!is.na(espaco[yfemea,xfemea])){
        xfemea = sample(1:area, 1)
        yfemea = sample(1:area, 1)
      }
      espaco[yfemea,xfemea] = "f"
      
      #### Sorteando macho escolhido ####
      escolhido = sample(mdisp, 1, prob = dados$prob[dados$machoid %in% mdisp])
      
      #### salvando resultados ####
      distf = dist(posicao("f", espaco), posicao(escolhido, espaco))
      dados$distf[dados$machoid == escolhido] = distf
      dados$ttot[dados$machoid == escolhido] = sum(dados$distf, na.rm=TRUE)
      dados$femea[dados$machoid == escolhido] = femeas[j]
      dados$nsim = paste0("sim", k)
      dados$area = area
      
      dados = dados[order(dados$femea),]
      
      #### Voltando ao espaco inicial sem macho escolhido ####
      espaco[which(espaco == "f")] = NA
      espaco[which(espaco == escolhido)] = NA
      mindisp[j] = escolhido
      mdisp = dados$machoid[!dados$machoid %in% mindisp]
    }
    result = rbind(result, dados)
    storepos[[k]] =list(espaco_orig, posf)
    
    if(k %in% seq(1, nsim, 10)){
      paste("simulacao", k, "de", nsim, "concluida")
    }
    
  }
  result = result[-1,]
  result$femeasim = paste(result$femea, result$nsim, sep = "_")
  row.names(result) = 1:length(result$area)
  return(result)
}
```

# 3. Simulação

```{r}
set.seed(42)
#sim1 = saposim(nsim = 10000)
#save(sim1, file = "sim1.Rdata")
load("sim1.Rdata")
summary(sim1) # @rada, os valores fazem sentido??
```


# 4. Analise dos resultados

```{r}
library(lme4)
library(MASS)

# Análise exploratória
hist(sim1$ttot)
plot(sim1$ttot ~ sim1$prob)
plot(sim1$ttot ~ sim1$footpad)
plot(sim1$ttot ~ sim1$freqpad)
plot(sim1$ttot ~ sim1$tamapad)

# Modelos Mistos Generalizados
glmm1 = glmer(ttot~tamapad*freqpad*footpad*area + (1|nsim), family = Gamma, data=sim1)
# glmm2 = glmer(ttot~tamapad+freqpad+footpad+area + tamapad:freqpad + freqpad:footpad +tamapad:footpad
#              + (1|nsim), family = Gamma, data=sim1)
AICtab(glmm1, glmm2)  #melhor glmm e o modelo cheio com interacoes


# Modelos Generalizados
glm1 = glm(ttot~tamapad*freqpad*footpad*area, family = Gamma, data=sim1)
stepAIC(glm1) #melhor glm e o modelo cheio com interacoes

#Comparacao de modelos
AICtab(glmm1, glm1, base = TRUE)

confint(glm1) < 0 & confint(glm1) > 0
```

